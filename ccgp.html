<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Phylogenetic Tree with Realistic Sample Locations</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    body { display: flex; flex-direction: column; }
    #header { text-align: center; font-size: 24px; font-weight: bold; padding: 10px; background-color: #f4f4f4; }
    #tree-container { width: 50%; border-right: 1px solid #ccc; padding: 10px; position: relative; }
    #map { width: 50%; height: 100vh; }
    svg { width: 100%; height: 100vh; padding-left: 20px; }
    #metadata-popup {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: white;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="header">California Conservation Genomics Project</div>
  <div style="display: flex; width: 100%;">
    <div id="tree-container">
      <div id="metadata-popup"></div>
    </div>
    <div id="map"></div>
  </div>

  <script>
    // [Previous code remains exactly the same until the markers section]

    // Inline Newick parser
    function parseNewick(s) {
      let ancestors = [];
      let tree = {};
      let tokens = s.split(/\s*(;|\(|\)|,|:)\s*/);
      let nodeCounter = 0;
      for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i];
        switch (token) {
          case '(':
            let subtree = {};
            tree.children = [subtree];
            ancestors.push(tree);
            tree = subtree;
            break;
          case ',':
            let sibling = {};
            ancestors[ancestors.length - 1].children.push(sibling);
            tree = sibling;
            break;
          case ')':
            tree = ancestors.pop();
            break;
          case ':':
            break;
          default:
            let x = tokens[i - 1];
            if (x === ')' || x === '(' || x === ',') {
              tree.name = token || `Node_${nodeCounter++}`;
            } else if (x === ':') {
              tree.branch_length = parseFloat(token);
            }
        }
      }
      return tree;
    }

    // Define the Newick tree (example structure)
    const newickString = "((A:0.1,B:0.2,(C:0.3,D:0.4):0.5):0.6,E:0.7);";
    
    const californiaBounds = {
      minLat: 32.5,
      maxLat: 42.0,
      minLon: -124.5,
      maxLon: -114.0
    };

    function generateRandomLocations(numLocations) {
      const locations = [];
      for (let i = 0; i < numLocations; i++) {
        const lat = californiaBounds.minLat + Math.random() * (californiaBounds.maxLat - californiaBounds.minLat);
        const lon = californiaBounds.minLon + Math.random() * (californiaBounds.maxLon - californiaBounds.minLon);
        locations.push([lat, lon]);
      }
      return locations;
    }

    const sampleLocations = {
      "A": generateRandomLocations(120),
      "B": generateRandomLocations(130),
      "C": generateRandomLocations(110),
      "D": generateRandomLocations(125),
      "E": generateRandomLocations(140)
    };

    function generateRandomDate() {
      const now = new Date();
      const past = new Date(now.getFullYear() - 10, now.getMonth(), now.getDate());
      const randomDate = new Date(past.getTime() + Math.random() * (now.getTime() - past.getTime()));
      return randomDate.toISOString().split('T')[0];
    }

    const sampleMetadata = {
      "A": { collection_date: generateRandomDate() },
      "B": { collection_date: generateRandomDate() },
      "C": { collection_date: generateRandomDate() },
      "D": { collection_date: generateRandomDate() },
      "E": { collection_date: generateRandomDate() }
    };

    const treeData = parseNewick(newickString);

    const svg = d3.select("#tree-container").append("svg"),
          width = 600, height = 800;
    svg.attr("width", width).attr("height", height);

    const layout = d3.tree().size([height, width - 180]);
    const root = d3.hierarchy(treeData);
    layout(root);

    const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

    const xOffset = 30;
    svg.selectAll(".link")
       .data(root.links())
       .enter().append("line")
       .attr("class", "link")
       .attr("x1", d => d.source.y + xOffset)
       .attr("y1", d => d.source.x)
       .attr("x2", d => d.target.y + xOffset)
       .attr("y2", d => d.target.x)
       .attr("stroke", "#555");

    svg.selectAll(".node")
       .data(root.descendants())
       .enter().append("circle")
       .attr("class", "node")
       .attr("cx", d => d.y + xOffset)
       .attr("cy", d => d.x)
       .attr("r", 10)
       .attr("fill", function(d) {
         return d.children ? "#555" : colorScale(d.data.name);
       })
       .style("cursor", "pointer")
       .on("click", function(event, d) { onNodeClick(event, d); });

    svg.selectAll(".node-label")
       .data(root.descendants())
       .enter().append("text")
       .attr("class", "node-label")
       .attr("x", d => d.y + xOffset + 15)
       .attr("y", d => d.x)
       .attr("dy", ".35em")
       .attr("font-size", "16px")
       .attr("fill", "#333")
       .text(d => d.children ? "" : d.data.name);

    const map = L.map('map').setView([36.7783, -119.4179], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    let markers = [];

    function countSamples(d) {
      if (!d.children) {
        return sampleLocations[d.data.name]?.length || 0;
      }
      return d.descendants()
        .filter(node => !node.children)
        .reduce((sum, node) => sum + (sampleLocations[node.data.name]?.length || 0), 0);
    }

    function countDescendantTips(d) {
      // If node is a leaf, return 1 (it's a tip)
      if (!d.children) {
        return 1;
      }
      // Otherwise, recursively count descendant tips
      return d.descendants().filter(node => !node.children).length;
    }

    function updateMetadataPopup(d) {
      const popup = document.getElementById('metadata-popup');
      const sampleCount = countSamples(d);
      const tipCount = countDescendantTips(d); // Count tips for internal nodes
      
      const name = d.children ? `Node ${d.data.name}` : `Taxon ${d.data.name}`;
      
      popup.innerHTML = `
        <strong>${name}</strong><br>
        Total Samples: ${sampleCount}<br>
        species: ${tipCount}
      `;
    }

    // Calculate marker size based on total number of visible points
    function calculateMarkerSize(totalPoints) {
      // Base size when only one tip is selected (120-150 points)
      const baseSize = 10;
      // Maximum number of points (all tips selected, ~625 points in this example)
      const maxPoints = 625;
      
      // Calculate size with a minimum of 3 pixels
      return Math.max(3, baseSize * Math.sqrt(150 / totalPoints));
    }

    function onNodeClick(event, d) {
      clearMarkers();
      updateMetadataPopup(d);

      // Collect all locations that will be displayed
      let allLocations = [];
      if (sampleLocations[d.data.name] && sampleLocations[d.data.name].length > 0) {
        allLocations = sampleLocations[d.data.name];
      } else if (d.children) {
        d.children.forEach(child => {
          if (sampleLocations[child.data.name] && sampleLocations[child.data.name].length > 0) {
            allLocations = allLocations.concat(sampleLocations[child.data.name]);
          }
        });
      }

      allLocations.forEach(location => {
        const marker = L.circleMarker(location, {
          radius: calculateMarkerSize(allLocations.length),
          color: "#ff7800",
          weight: 1,
          opacity: 0.5,
          fillOpacity: 0.5
        }).addTo(map);
        markers.push(marker);
      });
    }

    function clearMarkers() {
      markers.forEach(marker => marker.remove());
      markers = [];
    }
  </script>
</body>
</html>
